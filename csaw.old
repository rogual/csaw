#!/usr/bin/env python3

import sys
import os
import re
import clang.cindex
import subprocess
import functools
from clang.cindex import CursorKind, StorageClass


def dump(node, depth = 0):
    print(' ' * depth, node.kind, node.displayname)
    #print(dir(node))
    if 1:
        for c in node.get_children():
            dump(c, depth + 1)


def get_text(text, node):
    return text[
        node.extent.start.offset : node.extent.end.offset
    ].decode('utf-8')


# Configure Clang
clang.cindex.Config.set_library_path('/Applications/Xcode.app/Contents/Frameworks') 

# Parse args
import glob
sources = sys.argv[1:]


# STEP 1: Forward-declare types
# -----------------------------

with open('unit0.cc', 'wt') as unit0_src:
    for src in sources:
        with open(src, 'rt') as fin:
            print('#line 1 "%s"' % src, file=unit0_src)
            unit0_src.write(fin.read())

with open('unit0.cc', 'rb') as unit0_src:
    unit0_text = unit0_src.read()


# Parse concatenated file
index = clang.cindex.Index.create()
unit0 = index.parse('unit0.cc')

all_types = set()


def forward_declare_classes(fout, node):
    if node.kind == CursorKind.TRANSLATION_UNIT:
        for child in node.get_children():
            forward_declare_classes(fout, child)
    elif node.kind == CursorKind.CLASS_DECL:
        all_types.add(node.spelling)
        print('class %s;' % node.spelling, file=fout)

    elif node.kind == CursorKind.STRUCT_DECL:
        all_types.add(node.spelling)
        print('struct %s;' % node.spelling, file=fout)

    elif node.kind == CursorKind.OBJC_INTERFACE_DECL:
        all_types.add(node.spelling)
        print('@class %s;' % node.spelling, file=fout)


def output_typedefs(fout, node):
    print('otd')
    if node.kind == CursorKind.TRANSLATION_UNIT:
        for child in node.get_children():
            output_typedefs(fout, child)
    elif node.kind in [CursorKind.TYPEDEF_DECL]:
        print(node.spelling, '-'*10)
        all_types.add(node.spelling)
        print(get_text(unit0_text, node) + ';', file=fout)

with open('unit1.cc', 'wt') as unit1_src:
    forward_declare_classes(unit1_src, unit0.cursor)
    output_typedefs(unit1_src, unit0.cursor)
    with open('unit0.cc', 'rt') as unit0_src:
        unit1_src.write(unit0_src.read())

with open('unit1.cc', 'rb') as unit1_src:
    unit1_text = unit1_src.read()

# Parse amended file
index = clang.cindex.Index.create()
unit1 = index.parse('unit1.cc', args=['-std=c++11', '-ferror-limit=0', '-x', 'objective-c++'])


# STEP 2: Find interface dependencies
# -----------------------------------


def find_interface_dependencies(out_edges, out_nodes, node, dependent):

    if node.spelling == 'Clip':
        print(node.type, dir(node.type))
        dump(node)

    if node.kind in [CursorKind.CLASS_DECL, CursorKind.STRUCT_DECL]:

        if not dependent:
            dependent = node
            
        if node.spelling == 'VIFRenderer':
            out_edges.append(('VIFBitmap', 'VIFRenderer'))

        out_nodes.add(node.spelling)

        text = get_text(unit1_text, node)
        if '{' in text:
            print('dec', node.spelling)
            text = text[:text.index('{')]
            if ':' in text:
                text = text[text.index(':')+1:]
                text = re.sub(r'\bpublic|private|protected|,', '', text)
                deps = text.strip().split()
                for dep in deps:
                    print('dep inh', dep, node.spelling)
                    out_edges.append((dep, node.spelling))

        for child in node.get_children():
            if child.kind in [CursorKind.FIELD_DECL, CursorKind.VAR_DECL]:
                if child.type.spelling in all_types:
                    print('dep field', child.type.spelling, dependent.spelling)
                    out_edges.append((child.type.spelling, dependent.spelling))

    for child in node.get_children():
        find_interface_dependencies(out_edges, out_nodes, child, dependent)


edges = []
nodes = all_types
print(nodes)
find_interface_dependencies(edges, nodes, unit1.cursor, None)


def tsort(edges, nodes):

    with open('ideps', 'wt') as f:
        for a, b in edges:
            print(a, b, file=f)
        for n in nodes:
            print(n, '_', file=f)
            
    out = subprocess.check_output(
        ['/usr/bin/tsort', os.path.abspath('ideps')]
    )

    out = out.decode('utf-8').strip().split('\n')

    return [
        x for x in out
        if x != '_'
    ]
     

deps = tsort(edges, nodes)
for dep in deps:
    print('d', dep)


# STEP 3: Emit interfaces in dependency order
# -------------------------------------------


def find_records(node):
    if node.kind == CursorKind.TRANSLATION_UNIT:
        for child in node.get_children():
            yield from find_records(child)

    elif node.kind in [CursorKind.CLASS_DECL, CursorKind.STRUCT_DECL]:
        if node.is_definition():
            yield node

    elif node.kind in [CursorKind.TYPEDEF_DECL]:
        yield node


def emit_line_ref(fout, node):
    line = node.extent.start.line
    path = node.extent.start.file.name
    #print('#line %i "%s"' % (line, path), file=fout)


def spaff(fout, node, end=''):
    print(get_text(unit1_text, node) + end, file=fout)


def declare_function(fout, node):
    text = get_text(unit1_text, node)
    brace = text.find('{')


    text = text.replace('::', '$$')
    
    text = text[:brace]

    colon = text.find(':')
    if colon != -1:
        text = text[:colon]

    text = text.replace('$$', '::')

    decl = text.rstrip() + ';'

    print(decl, file=fout)


def emit(fout, node, mode):
    emit_line_ref(fout, node)

    text = get_text(unit1_text, node)

    if node.kind == CursorKind.TYPEDEF_DECL:
        print(text + ';', file=fout)
        return

    obrace = text.index('{')
    cbrace = text.rindex('}')

    if mode == 'h':
        print(text[:obrace + 1], file=fout)
    else:
        print('//c')

    for child in node.get_children():
        if child.kind in [CursorKind.CXX_BASE_SPECIFIER]:
            pass
        elif child.kind in [CursorKind.CXX_ACCESS_SPEC_DECL]:
            if mode == 'h':
                spaff(fout, child)
        elif (
                child.kind in [CursorKind.FIELD_DECL, CursorKind.VAR_DECL] and 
                child.storage_class == StorageClass.STATIC
        ):
            # Static const int: Header only
            # Static: Split
            ctext = get_text(unit1_text, child)

            if 'const int' in ctext:
                if mode == 'h':
                    print(ctext + ';', file=fout)
            else:
                try:
                    eq = ctext.index('=')
                    ctext = ctext[:eq]
                except ValueError:
                    pass

                if mode == 'h':
                    print(ctext + ';', file=fout)
                                
        elif child.kind in [CursorKind.FIELD_DECL,
                            CursorKind.VAR_DECL,
                            CursorKind.ENUM_DECL,
                            CursorKind.STRUCT_DECL,
                            CursorKind.FRIEND_DECL,
                            CursorKind.TYPEDEF_DECL]:
            if mode == 'h':
                spaff(fout, child, end=';')

        elif child.kind in [CursorKind.CXX_METHOD,
                            CursorKind.CONSTRUCTOR,
                            CursorKind.DESTRUCTOR]:
            if child.is_definition():
                if mode == 'h':
                    declare_function(fout, child)
                else:
                    ctext = get_text(unit1_text, child)
                    ctext = ctext.replace(child.spelling, node.spelling + '::' + child.spelling)
                    print(ctext, file=fout)
            else:
                spaff(fout, child, end=';')
        else:

            print('//', child.kind, child.spelling, file=fout)

    if mode == 'h':
        print(text[cbrace:] + ';', file=fout)


def emit_interfaces(fout, node, deps):
    records = {}
    for record in find_records(node):
        records[record.spelling] = record

    records = [
        records[name]
        for name in deps
        if name in records
    ]

    for record in records:
        if record.kind == CursorKind.TYPEDEF_DECL:
            emit(fout, record, 'h')

    for record in records:
        if record.kind != CursorKind.TYPEDEF_DECL:
            emit(fout, record, 'h')


def emit_implementations(fout, node, deps):
    records = {}
    for record in find_records(node):
        records[record.spelling] = record

    records = [
        records[name]
        for name in deps
        if name in records
    ]

    for record in records:
        if record.kind != CursorKind.TYPEDEF_DECL:
            emit(fout, record, 'c')

    
with open('unit2.h', 'wt') as unit2_hdr:
    forward_declare_classes(unit2_hdr, unit1.cursor)
    emit_interfaces(unit2_hdr, unit1.cursor, deps)

with open('unit2.cc', 'wt') as unit2_src:
    emit_implementations(unit2_src, unit1.cursor, deps)


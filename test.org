* variable
** uninitialized
*** in
    int a;
*** source
    int a;
*** header
    extern int a;
** initialized with =
*** in
int a = 3;
*** source
int a = 3;
*** header
extern int a;
** initialized with ()
*** in
    int a(3);
*** source
    int a(3);
*** header
    extern int a;
** multi
*** in
    int a = 3, b, *c, d = 47;
*** source
    int a = 3, b, *c, d=47;
*** header
    extern int a, b, *c, d;

** multiword type
*** in
long long int a = 1;
*** source
long long int a = 1;
*** header
extern long long int a;

** array
*** in
int a[64];
*** source
int a[64];
*** header
extern int a[64];

* typedef
** simple
*** in
typedef int a;
*** header
typedef int a;
** multi
*** in
typedef int a, *b;
*** header
typedef int a, *b;
** unusual spelling
*** in
int typedef long a;
*** header
int typedef long a;

* struct
** simple
*** in
struct Thing { int a, b; char *c; };
*** header
struct Thing;
struct Thing { int a, b; char *c; };

* typedef struct
** simple
*** in
typedef struct b { int a; } b;
*** header
struct b;
typedef struct b { int a; } b;

* union
** simple
*** in
    union Thing { int a, b; char *c; };
*** header
    union Thing;
    union Thing { int a, b; char *c; };

* typedef union
** simple
*** in
    typedef union Thing { int a, b; char *c; } d;
*** header
    union Thing;
    typedef union Thing { int a, b; char *c; } d;

* enum
** normal
*** in
enum MyEnum { a, b, c=3, d };
*** header
enum MyEnum { a, b, c=3, d };
** anonymous
*** in
    enum { a, b, c=3, d };
*** header
    enum { a, b, c=3, d };

* function
** simple
*** in
int fn(int a, char *b[]) {
  anything() !! notEvenReallyParsed(); <qqq>
  }
*** header
int fn(int a, char *b[]);
*** source
int fn(int a, char *b[]) {
    anything() !! notEvenReallyParsed(); <qqq>
}

** default arguments
*** in
int fn(int a=1) {
}
*** header
int fn(int a=1);
*** source
int fn(int a) {
}


* namespace
** simple
*** in
    namespace ns {
    int a;
    void f() {}
    struct q {
    void m() {}
    };
    }
*** header
    namespace ns {
    extern int a;
    void f();
    struct q;
    struct q {
    void m();
    };
    }
*** source
    namespace ns {
    int a;
    void f() {}
    void q::m() {}
    }
* member function
** simple
*** in
struct q { void f() {}};
*** header
struct q;
struct q { void f(); };
*** source
void q::f() {}

* template struct
** simple
*** in
    template<class T, class U>
    struct S {
    int q;
    int f() { return q; }
    };
*** header
    template<class T, class U>
    struct S {
    int q;
    int f() { return q; }
    };

* template function
** simple
*** in
template<class T, class U>
T f(U a) {
    return a;
}
*** header
template<class T, class U> T f(U a);
template<class T, class U>
T f(U a) {
    return a;
}

* template member function
** simple
*** in
struct q {
    template<class T, class U>
    T f(U a) {
        return a;
    }
};
*** header
struct q;
struct q {
    template<class T, class U>
    T f(U a);
};
*** source
template<class T, class U>
T q::f(U a) {
    return a;
}

* typedef template
** typedef before template
*** in
typedef S<int> Sint;
template<class T> struct S {};
*** header
template<class T> struct S {};
typedef S<int> Sint;
** template before typedef
*** in
template<class T> struct S {};
typedef S<int> Sint;
*** header
template<class T> struct S {};
typedef S<int> Sint;

* lambda in ()-assignment
** basic
*** in
Thing myThing("hi", []() {});
*** header
extern Thing myThing;
*** source
Thing myThing("hi", []() {});
** heavy
*** in
Thing myThing("hi", []() {
   blah("poo");
});
*** header
extern Thing myThing;
*** source
Thing myThing("hi", []() {
    blah("poo");
});
** confusing
*** in
Thing myThing("hi", []() {
    blah("))))");
    int q = 4;
});
*** header
extern Thing myThing;
*** source
Thing myThing("hi", []() {
    blah("))))");
    int q = 4;
});
* operators
** assignment
*** in
struct S {
S &operator=(const S &) {}
};
*** header
struct S;
struct S {
S &operator=(const S &);
};
*** source
S &S::operator=(const S &) {}

** conversion
*** in
struct S {
operator int() { return 4; }
};
*** header
struct S;
struct S {
    operator int();
};
*** source
S::operator int() { return 4; }

** multiply (member)
*** in
struct S {
    int operator*(int i) { return 4; }
};

*** header
struct S;
struct S {
    int operator*(int i);
};

*** source
int S::operator*(int i) { return 4; }

** multiply (non-member)
*** in
struct S {
};

int operator*(int i, S &s) { return 4; }

*** header
struct S;
struct S {
};

int operator*(int i, S &s);

*** source
int operator*(int i, S &s) { return 4; }

* typedef dependencies
** param
*** in
struct S {};
void f(T) {}
typedef S T;
*** header
struct S;
struct S {};
typedef S T;
void f(T);
*** source
void f(T) {}

** return
*** in
struct S {};
T f() { return T(); }
typedef S T;
*** header
struct S;
struct S {};
typedef S T;
T f();
*** source
T f() { return T(); }

* __declspec(property)
** read-only
*** in
struct S {
    int getX() { return 42; }
    __declspec(property(get=getX)) int x;
};
*** header
struct S;
struct S {
    int getX();
    __declspec(property(get=getX)) int x;
};
*** source
int S::getX() { return 42; }

** read-write
*** in
struct S {
    int getX() { return 42; }
    void setX(int x) {}
    __declspec(property(get=getX,put=setX)) int x;
};
*** header
struct S;
struct S {
    int getX();
    void setX(int x);
    __declspec(property(get=getX, put=setX)) int x;
};
*** source
int S::getX() { return 42; }
void S::setX(int x) {}

#!/usr/bin/env python3

import re
import sys
import argparse

from collections import defaultdict

from clang.cindex import (
    Index, CursorKind, StorageClass, Config, TranslationUnit,
    TokenKind
)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-oc', metavar='PATH', help='Output source file')
    parser.add_argument('-oh', metavar='PATH', help='Output header file')
    parser.add_argument('-i', metavar='PATH', help='Includes to add to generated source', nargs='*')
    parser.add_argument('inputs', nargs='+', help='Input files')
    args = parser.parse_args()

    if args.oc is None and args.oh is None:
        parser.error('at least one of -oc and -oh must be specified.')

    Database(args.inputs, args.oc, args.oh, args.i).emit_all()


class Database:

    def __init__(self, input_paths, c_path, h_path, includes):
        self.input_paths = input_paths
        self.c_path = c_path
        self.h_path = h_path
        self.includes = includes

        Config.set_library_path(
            '/Applications/Xcode.app/Contents/Frameworks'
        )

        self.index = Index.create()

        self.options = (
            0
            # | TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD
            # | TranslationUnit.PARSE_SKIP_FUNCTION_BODIES
            # | TranslationUnit.PARSE_INCOMPLETE
        )

        self.args = [
            '-std=c++11',
            '-x', 'objective-c++',
            '-I/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1',
            '-I /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.1/include'

        ]

    def emit_all(self):
        c_path = self.c_path
        h_path = self.h_path
        if c_path and h_path:
            with open(c_path, 'wt') as f:
                f.write('#include "%s"\n' % h_path)
                self.emit_file('c', f)

            with open(h_path, 'wt') as f:
                self.emit_file('h', f)

        elif c_path:
            with open(c_path, 'wt') as f:
                self.emit_file('h', f)
                self.emit_file('c', f)

        elif h_path:
            with open(h_path, 'wt') as f:
                self.emit_file('h', f)

        else:
            assert False

    def build_objc_method_map(self):
        """
        Life's also too short to copy method prototypes into objc @implementation
        sections. Find all methods & index by class so we can auto-generate their
        prototypes later.
        """
        decls = self.get_decls()
        self.objc_method_map = defaultdict(list)
        for node, source_text in decls:
            if node.kind == CursorKind.OBJC_IMPLEMENTATION_DECL:
                for child in node.get_children():
                    if child.kind == CursorKind.OBJC_INSTANCE_METHOD_DECL:
                        self.objc_method_map[node.spelling].append(child)

    def emit_file(self, mode, f):
        if mode == 'h' and self.includes:
            for include in self.includes:
                print('#include "%s"' % include, file=f)
            print(file=f)


        decls = self.get_decls()

        if mode == 'h':
            self.emit_forward_declarations(f)
            decls = sort_decls(decls)
            self.build_objc_method_map()

        for node, source_text in decls:
            self.emit_node(mode, f, node, source_text)

    def emit_node(self, mode, f, node, source_text):

        print('//', node.kind, node.spelling, file=f)
        if node.kind == CursorKind.FUNCTION_DECL:
            if mode == 'h':
                text = get_text(source_text, node)
                obrace = text.index('{')
                text = text[:obrace].strip() + ';'

                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

            elif mode == 'c':
                text = get_text(source_text, node)
                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

        elif node.kind in [
                CursorKind.CLASS_DECL,
                CursorKind.STRUCT_DECL
        ]:
            self.emit_class(mode, f, node, source_text)

        elif node.kind == CursorKind.ENUM_DECL:
            if mode == 'h':
                text = get_text(source_text, node) + ';'
                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

        elif node.kind == CursorKind.FRIEND_DECL:
            if mode == 'h':
                text = get_text(source_text, node) + ';'
                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

        elif node.kind == CursorKind.FIELD_DECL:
            if mode == 'h':

                # FIXME
                # clang python doesn't expose initializers
                # Probably a real fix means dropping python
                if source_text[node.extent.end.offset:].lstrip().startswith(b'='):
                    semi = source_text[node.extent.end.offset:].index(b';')
                    ntext = source_text[
                        node.extent.start.offset : node.extent.end.offset + semi
                    ].decode('utf-8')

                else:
                    ntext = get_text(source_text, node)

                    # Clang is broken
                    if ntext == '':
                        ntext = source_text[node.location.offset:]
                        ntext = ntext[:ntext.index(b';')].decode('utf-8')

                print(file=f)
                print(line_directive(node.location), file=f)
                print(ntext + ';', file=f)

        elif node.kind in [
                CursorKind.CXX_METHOD,
                CursorKind.CONSTRUCTOR,
                CursorKind.DESTRUCTOR
        ]:
            text = get_text(source_text, node)
            obrace = text.find('{')

            if mode == 'h':
                if obrace == -1:
                    # Method without a body
                    print(file=f)
                    print(line_directive(node.location), file=f)
                    print(text + ';', file=f)

                else:
                    # Method with a body
                    text = text[:obrace].strip() + ';'

                    # FIXME: Super janky!
                    inits = text.find('):')
                    if inits != -1:
                        text = text[:inits] + ');'

                    print(file=f)
                    print(line_directive(node.location), file=f)
                    print(text, file=f)

            elif mode == 'c':

                # We only care about methods with bodies
                if obrace != -1:
                    class_node = node.semantic_parent

                    text = text.replace(
                        node.spelling,
                        '%s::%s' % (
                            class_node.spelling,
                            node.spelling
                        ),
                        1
                    )

                    text = re.sub('^static ', '/* static */ ', text)

                    text = re.sub('^virtual ', '/* virtual */ ', text)
                    text = re.sub(r'\boverride\b', '/* override */ ', text)

                    text = unindent(text)

                    print(file=f)
                    print(line_directive(node.location), file=f)
                    print(text, file=f)

        elif node.kind == CursorKind.CXX_ACCESS_SPEC_DECL:
            if mode == 'h':
                text = get_text(source_text, node)
                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

        elif node.kind == CursorKind.OBJC_INSTANCE_METHOD_DECL:
            text = get_text(source_text, node)
            if mode == 'c':
                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

            elif mode == 'h':
                obrace = text.find('{')
                if obrace != -1:
                    text = text[:obrace].strip() + ';'
                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

        elif node.kind == CursorKind.OBJC_CLASS_REF:
            pass

        elif node.kind == CursorKind.OBJC_INTERFACE_DECL:
            if mode == 'h':
                text = get_text(source_text, node)
                text = re.sub('@end$', '', text.strip())

                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

                for method in self.objc_method_map[node.spelling]:
                    text = get_text(source_text, method)
                    obrace = text.find('{')
                    text = text[:obrace].strip() + ';'

                    print(file=f)
                    print(line_directive(method.location), file=f)
                    print(text, file=f)

                print('@end', file=f)

        elif node.kind == CursorKind.OBJC_IMPLEMENTATION_DECL:
            if mode == 'c':
                text = get_text(source_text, node)
                m = re.match(r'@implementation \w+', text)

                print(file=f)
                print(line_directive(node.location), file=f)
                print(m.group(0), file=f)

                for child in node.get_children():
                    self.emit_node(mode, f, child, source_text)

                print('\n@end', file=f)

        elif node.kind == CursorKind.TYPEDEF_DECL:
            if mode == 'h':
                text = get_text(source_text, node) + ';'
                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

        elif node.kind == CursorKind.VAR_DECL:
            if mode == 'h':
                text = get_text(source_text, node) + ';'
                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

            elif mode == 'c':
                text = get_text(source_text, node) + ';'
                if 'static const int' not in text:
                    class_node = node.semantic_parent
                    text = text.replace(
                        node.spelling,
                        '%s::%s' % (
                            class_node.spelling,
                            node.spelling
                        ),
                        1
                    )
                    text = text.replace('static ', '')
                    print(file=f)
                    print(line_directive(node.location), file=f)
                    print(text, file=f)

        elif node.kind == CursorKind.FUNCTION_TEMPLATE:
            if mode == 'h':
                text = get_text(source_text, node)
                print(file=f)
                print(line_directive(node.location), file=f)
                print(text, file=f)

        else:
            print('//', node.kind, node.spelling)
            print('//', node.kind, node.spelling, file=f)

    def emit_class(self, mode, f, class_node, source_text):
        if mode == 'h':
            text = get_text(source_text, class_node)
            obrace = text.index('{')
            cbrace = text.rindex('}')

            print(file=f)
            print(line_directive(class_node.location), file=f)
            print(text[:obrace + 1], file=f)

            for node in class_node.get_children():
                self.emit_node(mode, f, node, source_text)

            print(text[cbrace:] + ';', file=f)

        elif mode == 'c':
            for node in class_node.get_children():
                self.emit_node(mode, f, node, source_text)

    def get_decls(self):
        for path in self.input_paths:
            unit = self.index.parse(path, args=self.args, options=self.options)
            with open(path, 'rb') as f:
                source_text = f.read()

            for node in unit.cursor.get_children():
                yield node, source_text

    def emit_forward_declarations(self, f):
        for decl, source_text in self.get_decls():
            if decl.kind == CursorKind.CLASS_DECL:
                print('class %s;' % decl.spelling, file=f)
            elif decl.kind == CursorKind.STRUCT_DECL:
                print('struct %s;' % decl.spelling, file=f)
            elif decl.kind == CursorKind.ENUM_DECL:
                text = get_text(source_text, decl)
                obrace = text.index('{')
                text = text[:obrace]
                print('%s;' % text, file=f)
            elif decl.kind == CursorKind.OBJC_INTERFACE_DECL:
                print('@class %s;' % decl.spelling, file=f)


def line_directive(location):
    return '#line %i "%s"' % (location.line, location.file)


def dump(node, depth = 0):
    if '/Applications/Xcode.app/' in str(node.location):
        return
    
    print(' ' * depth, node.location, node.kind, node.displayname)
    if node.kind == CursorKind.FIELD_DECL:
        print('type=', node.type.spelling)
    #print(dir(node))
    if 1:
        for c in node.get_children():
            dump(c, depth + 1)


def unindent(text):
    ms = re.findall(r'\n +', text)
    if ms:
        shortest = min(ms, key=len)
        return text.replace(shortest, '\n')
    return text


def get_text(text, node):
    return text[
        node.extent.start.offset : node.extent.end.offset
    ].decode('utf-8')


def sort_decls(decls):
    decls = list(decls)

    names = set()

    done_names = set()
    names = set(t.spelling for t, source_text in decls)

    items = []
    
    for t, source_text in decls:
        deps = get_dependencies(t, names)
        items.append((t, source_text, deps))

    ordered = []
    while items:
        for i, (t, source_text, deps) in enumerate(items):
            if all(dep in done_names for dep in deps):
                if t.spelling not in done_names:
                    ordered.append((t, source_text))
                    done_names.add(t.spelling)
                del items[i]
                break
        else:
            print('cycle in dependencies')
            for t, source_text, deps in items:
                deps = [x for x in deps if x not in done_names]
                print('%s depends on: %s' % (t.spelling, deps))
            sys.exit(1)

    for q, t in ordered:
        print(q.spelling)
              
    return ordered


def get_node_tree(node):
    yield node
    for child in node.get_children():
        yield from get_node_tree(child)


def get_dependencies(node, names):
    # There's a dependency when:
    # Class has a base class
    # Class has a field of type
    # Function returns a type

    # For templates, we'll probably need to supply metadata
    # manually on which template args need be fully defined.

    deps = set()

    # Find base classes
    if node.kind == CursorKind.CLASS_DECL:
        for t in node.get_tokens():
            if t.kind == TokenKind.IDENTIFIER and t.spelling != node.spelling:
                if t.spelling in names:
                    deps.add(t.spelling)
            if t.kind == TokenKind.PUNCTUATION and t.spelling == '{':
                break

    # Find function returns and fields
    for child in get_node_tree(node):

        # Fields
        if child.kind == CursorKind.FIELD_DECL:
            tokens = list(child.get_tokens())
            for i, t in enumerate(tokens):
                if t.kind == TokenKind.PUNCTUATION and t.spelling == '=':
                    break
                if t.kind == TokenKind.IDENTIFIER:
                    if t.spelling in names:
                        # FIXME: Use clang to find actual return type
                        if tokens[i + 1].spelling not in '*&':
                            deps.add(t.spelling)

        # Function returns
        elif child.kind == CursorKind.CXX_METHOD:

            tokens = list(child.get_tokens())
            
            for i, t in enumerate(tokens):
                if t.kind == TokenKind.IDENTIFIER and t.spelling != node.spelling:
                    if t.spelling in names:
                        # FIXME: Use clang to find actual return type
                        if tokens[i + 1].spelling not in '*&':
                            deps.add(t.spelling)
                if t.kind == TokenKind.PUNCTUATION and t.spelling == '{':
                    break

    return deps


if __name__ == '__main__':
    main()
